/*****************************************************************************/
//
// Module          : vadd.vpp
// Revision        :  Revision: 1.2  
// Last Modified On:  Date: 2013/01/23 17:31:48  
// Last Modified By:  Author: gedwards  
//
//-----------------------------------------------------------------------------
//
// Original Author : gedwards
// Created On      : Wed Oct 10 09:26:08 2007
//
//-----------------------------------------------------------------------------
//
// Description     : Sample personality vector add unit
//
//-----------------------------------------------------------------------------
//
// Copyright (c) 2007-2012 : created by Convey Computer Corp. This model is the
// confidential and proprietary property of Convey Computer Corp.
//
/*****************************************************************************/
/*  Id: vadd.vpp,v 1.2 2013/01/23 17:31:48 gedwards Exp   */

`timescale 1 ns / 1 ps

module vadd #(parameter CHUNKSIZE = 512)(
   input		clk,
   input		reset,

   input  [CHUNKSIZE-1:0] memorychunk,
   output [CHUNKSIZE-1:0] result_hash,
   input  [5:0]		fpnum,


   input  [11:0]	csr_ldst_thld
);

   /* ----------         include files        ---------- */

   // Use 63 pipes, instead of 64, to avoid stride of 64
   parameter NUM_FPS = 7'd63;
   parameter CHUNKLENGTH = 512;
   /* ----------          wires & regs        ---------- */

   reg  [31:0]  hash_value [0:7];
   reg  [31:0]  next_hash_value [0:7];
   reg  [31:0]  round_key [0:63];
   reg  [511:0] final_chunk;
   wire a [31:0];
   wire b [31:0];
   wire c [31:0];
   wire d [31:0];
   wire e [31:0];
   wire f [31:0];
   wire g [31:0];
   wire h [31:0];

   assign a = hash_value[0];
   assign b = hash_value[1];
   assign c = hash_value[2];
   assign d = hash_value[3];
   assign e = hash_value[4];
   assign f = hash_value[5];
   assign g = hash_value[6];
   assign h = hash_value[7];
   always @(posedge clk) begin
      r_req_ld <= c_req_ld;
      r_req_st <= c_req_st;
      r_req_vadr <= c_req_vadr;
      r_req_wrd_rdctl <= c_req_wrd_rdctl;
      r_mc_rd_rq_stall <= mc_rd_rq_stall;
      r_mc_wr_rq_stall <= mc_wr_rq_stall;
   end
   
   reg          r_mc_rd_rq_stall;
   reg          r_mc_wr_rq_stall;

   wire 	op1_fifo_afull;
   wire 	op2_fifo_afull;

   localparam IDLE   = 3'd0;
   localparam LD_OP1 = 3'd1;
   localparam LD_OP2 = 3'd2;
   localparam ST_RES = 3'd3;
   localparam AD_CHK = 3'd4;

   reg  [15:0]  c_ldst_cnt, r_ldst_cnt;

   /* ----------      combinatorial blocks    ---------- */
 assign finalchunk = {memorychunk,}
  // Outputs to smpl_pers
  
  // Load operands
  assign op_ld_rdctl = {63'b0, r_op_sel};

  assign op1_wea = r_mc_rsp_push && ~r_mc_rsp_rdctl[0];
  assign op2_wea = r_mc_rsp_push && r_mc_rsp_rdctl[0];

  assign c_result[64:0] = {1'b0, op1_ram_out[63:0]} + {1'b0, op2_ram_out[63:0]};
  assign c_result_vld = !op1_qempty && !op2_qempty && !res_fifo_afull;

  assign c_sum[64:0] = r_result_vld ? r_sum[64:0] + r_result[64:0] : r_sum[64:0];
  assign c_sum_vld = (r_st_addr >= r_last_addr3) || (fpnum>=NUM_FPS);

   /* ----------      external module calls   ---------- */

   fifo #(.DEPTH(2048), .WIDTH(64), .AFULLCNT(2000), .RAM_STYLE("block")) result_fifo (
    .clk    (clk),
    .reset  (r_reset),
    .push   (r_result_vld),
    .din    (r_result[63:0]),
    .afull  (res_fifo_afull),
    .full   (),
    .cnt    (),
    .oclk   (clk),
    .pop    (c_req_st),
    .dout   (res_st_data[63:0]),
    .empty  (res_qempty),
    .rcnt   ()
   );

   fifo #(.DEPTH(32), .WIDTH(64), .AFULLCNT(28)) op1_fifo (
    .clk    (clk),
    .reset  (r_reset),
    .push   (op1_wea),
    .din    (r_mc_rsp_data),
    .afull  (op1_fifo_afull),
    .full   (),
    .cnt    (),
    .oclk   (clk),
    .pop    (c_result_vld),
    .dout   (op1_ram_out),
    .empty  (op1_qempty),
    .rcnt   ()
   );

   fifo #(.DEPTH(32), .WIDTH(64), .AFULLCNT(28)) op2_fifo (
    .clk    (clk),
    .reset  (r_reset),
    .push   (op2_wea),
    .din    (r_mc_rsp_data),
    .afull  (op2_fifo_afull),
    .full   (),
    .cnt    (),
    .oclk   (clk),
    .pop    (c_result_vld),
    .dout   (op2_ram_out),
    .empty  (op2_qempty),
    .rcnt   ()
   );

   /* ----------            registers         ---------- */

   // ISE can have issues with global wires attached to D(flop)/I(lut) inputs
   FDSE rst (.C(clk),.S(reset),.CE(r_reset),.D(!r_reset),.Q(r_reset)); 

   always @(posedge clk) begin
      r_start  <= r_reset ? 1'b0 : start;
      r_start2 <= r_reset ? 1'b0 : r_start;
      r_state  <= r_reset ?  'd0 : nxt_state;
   end

   always @(posedge clk) begin
      r_req_ld <= c_req_ld;
      r_req_st <= c_req_st;
      r_req_vadr <= c_req_vadr;
      r_req_wrd_rdctl <= c_req_wrd_rdctl;
      r_mc_rd_rq_stall <= mc_rd_rq_stall;
      r_mc_wr_rq_stall <= mc_wr_rq_stall;
   end

   always @(posedge clk) begin
      r_last_addr1 <= c_last_addr1;
      r_last_addr2 <= c_last_addr2;
      r_last_addr3 <= c_last_addr3;
   end

   always @(posedge clk) begin
      r_ld_addr1   <= idle_reset ? 'd0 : c_ld_addr1;
      r_ld_addr2   <= idle_reset ? 'd0 : c_ld_addr2;
      r_st_addr    <= idle_reset ? 'd0 : c_st_addr;
      r_op_sel     <= idle_reset ? 'd0 : c_op_sel;
      r_result_vld <= idle_reset ? 'd0 : c_result_vld;
      r_sum_vld    <= idle_reset ? 'd0 : c_sum_vld;
      r_result     <= idle_reset ? 'd0 : c_result;
      r_sum        <= idle_reset ? 'd0 : c_sum;
      r_sum2       <= idle_reset ? 'd0 : r_sum;
      r_ldst_cnt   <= idle_reset ? 'd0 : c_ldst_cnt;
   end

   always @(posedge clk) begin
      r_mc_rsp_push  <= r_reset ? 1'b0 : mc_rsp_push;
      r_mc_rsp_rdctl <= r_reset ? 1'b0 : mc_rsp_rdctl;
      r_mc_rsp_data  <= r_reset ? 1'b0 : mc_rsp_data;
   end


   /* ---------- debug & synopsys off blocks  ---------- */

   // synopsys translate_off

   // Parameters: 1-Severity: Don't Stop, 2-start check only after negedge of reset
   //assert_never #(1, 2, "***ERROR ASSERT: unimplemented instruction cracked") a0 (.clk(clk), .reset_n(~reset), .test_expr(r_unimplemented_inst));

    // synopsys translate_on

endmodule // vadd

// This is the search path for the autoinst commands in emacs.
// After modification you must save file, then reld with C-x C-v
//
// Local Variables:
// verilog-library-directories:("." "../../common/xilinx")
// End:

